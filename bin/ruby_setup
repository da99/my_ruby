#!/usr/bin/env bash
# -*- bash -*-
#
#
action="$1"
shift

set -u -e -o pipefail
DIR="$( basename "$(pwd)" )"
TEMPLATES="/apps/ruby_setup/templates/gem"

PATH="/progs/ruby/current/bin:$PATH"

function git_is_clean {
    if ! git_repo_is_clean
    then
      echo -e "\n!!! GIT repo not clean enough.\n" 1>&2
      exit 1
    fi
}


case "$action" in

  "help")
    echo ""
    echo "  $ ruby_setup   class_name  My_Class"
    echo ""
    echo "  $ ruby_setup   install x.x.x"
    echo "  $ ruby_setup   install"
    echo ""
    echo "  $ mkdir  my_new_gem"
    echo "  $ cd     my_new_gem"
    echo "  $ ruby_setup   gem_init"
    echo "  $ ruby_setup   gem_init   bitbucket"
    echo "  $ ruby_setup   gem_release"
    echo ""
    exit 0
    ;;

  "install")
    cd /progs
    if [[ ! -d /progs/ruby-build ]]; then
      git clone https://github.com/sstephenson/ruby-build.git
    fi
    cd ruby-build
    git pull

    if [[ -z "$@" ]]; then
      bin/ruby-build --definitions
      echo "=== Choose one from the top."
      exit 0
    fi

    ver="$1"
    if [[ -d /progs/ruby/$ver ]]; then
      echo "=== Aborting: Already exists: /progs/ruby/$ver"
      exit 0
    fi

    echo "=== Linking $ver as current ruby:"
    bin/ruby-build install $ver /progs/ruby/$ver
    rm -f /progs/ruby/current
    ln -s /progs/ruby/$ver  /progs/ruby/current

    echo "=== Updating gems:"
    gem update
    gem update --system
    gem install bundler

    echo "=== Done installing."
    ruby -v

    ;;

  "class_name")
    ruby -e "puts ARGV[0].downcase.split('_').map(&:capitalize).join('_')" "$@"
    ;;

  "gem_release")
    rm -f ./*.gem
    git_is_clean
    gem build ./*.gemspec
    gem push "$(echo ./*.gem)"
    ;;

  "gem_bump_and_commit")
    bash_setup bump_and_commit "$@"
    ;;

  "gem_init")

    echo ""
    export name="$(basename $(pwd))"
    export NAME="$(ruby_setup class_name $name)"
    export today="$(date +"%Y-%m-%d")"
    export year="$(date +"%Y")"
    export user="$(git config --global user.name)"
    export email="$(git config --global user.email)"
    gemspec="${name}.gemspec"

    if [[ -z "$@" ]]; then
      export repo="github"
      export homepage="https://github.com/${user}/${name}"
      export repo_git="git@github.com:${user}/${name}.git"
    else
      export repo="bitbucket"
      export homepage="https://bitbucket.org/da99/${name}"
      export repo_git="git@bitbucket.org:${user}/${name}.git"
    fi

    mkdir -p specs
    mkdir -p lib
    mkdir -p bin

    ruby_setup template $TEMPLATES/Gemfile     Gemfile
    ruby_setup template $TEMPLATES/LICENSE.txt LICENSE.txt
    ruby_setup template $TEMPLATES/README.md   README.md
    ruby_setup template $TEMPLATES/the.gemspec ${name}.gemspec
    ruby_setup template $TEMPLATES/VERSION     VERSION
    ruby_setup template $TEMPLATES/.gitignore  .gitignore
    ruby_setup template $TEMPLATES/lib.rb      lib/${name}.rb
    ruby_setup template $TEMPLATES/helpers.rb  specs/helpers.rb

    ruby_setup template $TEMPLATES/test        bin/test
    chmod +x bin/test

    ruby_setup template $TEMPLATES/bundle      bin/bundle
    chmod +x bin/bundle

    if [[ "$(echo -n specs/*)" == "specs/helpers.rb" ]]; then
      ruby_setup template $TEMPLATES/first_test.rb specs/${name}.rb
    fi


    if [[ ! -d .git ]]; then
      git init
    fi

    if [[ -z "$(git remote -v)" ]]; then
      git_update
      git commit -m "Init."
      git remote add origin $repo_git
      colorize yellow "=== Added: git origin: $repo_git"
      colorize yellow "=== Set git upstream:\n    git push --set-upstream origin master"
    fi

    colorize green "=== Done gem init: $name"
    ;;

  "template")
    file="$1"
    output="$2"
    ruby_template='
      file  = ARGV[0]
      tmpl  = File.read(file)
      puts(tmpl.gsub(/{{([^}]+)}}/) do |match|
        raise "Var not found: #{$1}" unless ENV[$1]
        ENV[$1]
      end)
    '

    if [[ -f $output ]]; then
      colorize yellow "=== Skipping existing file: $output"
      exit 0
    fi

    # Note: eval and write the content separately.
    # If you combine those two steps, and an error
    # occurs during eval, an empty file will be created:
    #   ruby "error" >> $output
    content="$(ruby -e "$ruby_template" "$file")"
    echo "$content" >> "$output"
    colorize green "=== Wrote: $output"
    ;;

  *)
    echo "Unknown action: $action" 1>&2
    exit 1
    ;;
esac


